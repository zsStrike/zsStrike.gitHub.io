---
title: OnJava8笔记
date: 2020-10-25 23:15:42
tags: ["Java"]
---

本文主要整理了 OnJava8 的阅读笔记。

<!-- More -->

## 第三章 万物皆对象

对象操纵：在 Java 中程序员实际操作的是对象的引用，方法参数中传递的也只是对象的引用。

对象创建：new。

+ 数据存储：
  + 寄存器：Java 中不存在该方式。
  + 栈内存：存放一些 Java 数据，比如对象的引用。
  + 堆内存：Java 对象都存于其中。
  + 常量内存：程序代码中，不会改变。
  + 非 RAM 存储：序列化对象（用于传送）和持久化对象（用于恢复）。

+ 基本类型的存储：不是通过 new 创建，变量直接存储值。有 boolean，byte，short，char，int，float，long，double，void。boolean 类型的大小没有明确规定。

+ 高精度数值：BigInteger 和 BigDecimal。

+ 数组的存储：当创建对象数组的时候，实际上是对象引用的数组，初始化为 null。

代码注释：`/* ... */` 和 `//`。

对象清理：

+ 作用域：`{}` 决定，不允许父作用域和子作用域声明相同的变量。
+ 对象作用域：使用 new 关键字创建的 Java 对象生命周期超出作用域。

类的创建：

+ 类型：class
+ 字段：类里面声明的变量
+ 方法：类里面定义的函数
+ 基本类型的默认值：全 0，但是不适用与局部变量。
+ 方法签名：方法名和参数列表统称为方法签名。

程序编写：

+ 命名可见性：反向使用自己的网络域名，但是存在空文件夹
+ 使用其他组件：import
+ static 关键字：类变量和类方法声明，在没有对象时候也可以进行调用，另外类变量在所有的对象中共享



## 第四章 运算符

赋值：`=`，基本类型的赋值都是直接的，而不像对象，赋予的只是其内存的引用。在方法的参数中传递一个对象，在方法体里面对其进行修改，那么在该对象在外部也会被修改。

算术运算符：`+，-，*，/，%`，其中`+, -`可以作为一元运算符。

递增和递减：`++,--`。前缀递增和递减立即修改变量的值，后缀则是使用变量的值，然后再修改。

关系运算符：`>, >=, <, <=, ==, !=`。判断基本对象的时候使用`==`，判断对象的使用 equals 方法，判断对象时使用 `==` 比较的只是引用。

逻辑运算符：`&&, OR, !`。Java 支持短路。

字面量常量：`0x, 0, 0b, L, F, L`, F 可以默认不写。

下划线：用于分割数字字面量。

指数计数法：`e`。

位运算符：`&, |, ^, ~`。

移位运算符：`<<, >>, >>>`。注意 `>>` 是算术右移，`>>>` 是逻辑右移（首位添0）。

三目运算符：`<boolean condition> ? <value1> : <value2>`。

字符串运算符：`+`。

类型转换：向上转换是安全的，向下转换需要显式说明`(type)`。对于浮点数向整数转换，小数总是被截断。

Java 没有 sizeof 运算符，因为每种类型的值都是固定的。



## 第五章 控制流

true 和 false：所有关系运算符都能产生条件语句，注意在 Java 中使用数值作为布尔值是非法的。

条件控制：`if-else`。

迭代语句：`while`，`do-while`，`for`，`for-in`。

return：退出当前的方法，放回一个方法值。

break 和 continue：break 用于中止内层循环，continue 用于跳过此次迭代。

goto：Java 不支持 `goto` 语句，但是支持标签语法，可以和 break 和 continue 一起使用。

switch-case：每个 case 后面跟上 break，同时在 Java7 的时候开始支持字符串匹配。



## 第六章 初始化和清理

使用构造器保证初始化：构造器名称和类名相同，每次创建一个对象的时候，自动调用构造器进行初始化。构造器并没有返回值。

方法重载：每个被重载的方法需要具有一个独一无二的参数列表。返回值并不能用来区分重载的方法。

无参构造器：一个无参构造器就是不接受参数的构造器，如果没有显式提供任何构造器，那么编译器会自动提供一个无参构造器。

this：this 关键字只能在非静态的方法内部使用，等同于当前方法所属的对象引用。

在构造器中调用构造器：通过 `this(param list)` 实现。注意只能通过 this 调用一次构造器，不可重复多次调用构造器。并且，只能在构造器首行进行调用。

static 的含义：static 修饰的方法中不存在 this。静态方法和静态变量是为了类而创建的。

垃圾回收器：在 Java 中，对象并非总是被垃圾回收：

1. 对象可能不被垃圾回收。
2. 垃圾回收不等同于析构。
3. 垃圾回收只和内存有关。

在 Java 中，虽然提供了一个 `finialize()` 的方法用于清理对象，但是事实上我们并不需要过多使用该方法。记住，无论是"垃圾回收"还是"终结"，都不保证一定会发生。如果 Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。

垃圾回收器如何工作：

+ 引用计数：每个对象有一个引用计数器，每次有引用指向该对象的时候，引用计数加 1.当引用离开作用域或者被置为 null 的时候，引用计数减一。垃圾回收器会遍历含有全部对象的列表，当发现某个对象的引用计数为 0 时，就释放其占用的空间（但是，引用计数模式经常会在计数为 0 时立即释放对象）。这个机制存在一个缺点：如果对象之间存在**循环引用**，那么它们的引用计数都不为 0，就会出现应该被回收但无法被回收的情况。
+ 自适应的垃圾回收技术：对于任意“活”的对象，总是可以追溯到其存活在栈或者静态区的引用，从栈或者静态存储区出发，将会发现所有的活的对象。至于如何处理找到的存活对象，取决于不同的 Java 虚拟机实现。其中有一种做法叫做停止-复制（stop-and-copy）。顾名思义，这需要先暂停程序的运行（不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有复制的就是需要被垃圾回收的。另外，当对象被复制到新堆时，它们是一个挨着一个紧凑排列，然后就可以按照前面描述的那样简单、直接地分配新空间了。上述方法存在缺点：需要两个堆，然后再两个堆之间折腾，得维护比实际空间多一倍的空间；另外在于复制本身，一旦程序进入稳定状态之后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制回收器仍然会将所有内存从一处复制到另一处，这很浪费。为了避免这种状况，一些 Java 虚拟机会进行检查：要是没有新垃圾产生，就会转换到另一种模式（即"自适应"）。这种模式称为标记-清扫（mark-and-sweep）。对一般用途而言，"标记-清扫"方式速度相当慢，但是当你知道程序只会产生少量垃圾甚至不产生垃圾时，它的速度就很快了。"标记-清扫"所依据的思路仍然是从栈和静态存储区出发，遍历所有的引用，找出所有存活的对象。但是，每当找到一个存活对象，就给对象设一个标记，并不回收它。只有当标记过程完成后，清理动作才开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。"标记-清扫"后剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就需要重新整理剩下的对象。

成员初始化：在方法中的变量没有默认值，需要手动指定一个值之后才能使用；在类中的变量则会赋予默认值。

初始化的顺序：假设有个名为 **Dog** 的类：

1. 即使没有显式地使用 **static** 关键字，构造器实际上也是静态方法。所以，当首次创建 **Dog** 类型的对象或是首次访问 **Dog** 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 **Dog.class**。
2. 当加载完 **Dog.class** 后（后面会学到，这将创建一个 **Class** 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 **Class** 对象时初始化一次。
3. 当用 `new Dog()` 创建对象时，首先会在堆上为 **Dog** 对象分配足够的存储空间。
4. 分配的存储空间首先会被清零，即会将 **Dog** 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 **null**。
5. 执行所有出现在字段定义处的初始化动作。
6. 执行构造器。你将会在"复用"这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。

显式的静态初始化：`static { statements； }`，与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。

非静态实例初始化：`{ statements; }`，实例初始化子句是在两个构造器之前执行的。

数组初始化：`Type[] arg = new Type[length]`，`Type[] arg = {value1, value2,,,}`

可变参数列表：`void method(int t, char... args)`

枚举类型：`enum Type {}`



## 第七章 封装

包的概念：包内包含有一组类，它们被组织在一个单独的命名空间下。对于单文件的程序，该文件在默认包（default package）下。另外，每个 Java 源文件只能有一个 public 类。

代码组织：为了将功能相近的 Java 源文件组织到一起，可以使用关键字 package。该关键字必须是文件中除了注释的第一行代码。当需要使用到某个包中的类时，可以使用 import 关键字。

独一无二的包名：通常选择反转的域名。

冲突：当两个包下面含有相同的类时，就会出现名称冲突的问题，可以将特定的类写全名称，比如`java.util.ArrayList`。

使用包的注意事项：当创建一个包的时候，包名实际上就隐含了目录结构。

访问权限修饰符：Java 访问权限控制符 public，protected，private 位于定义的类名，属性名和方法名前。

public：当使用 public 关键字的时候，意味着 public 后声明的成员对于每个人都是可用的。

默认包：指不加修饰符定义的成员，可以被相同包下的文件访问。

private：除了包含成员的类，其他任何类都无法访问这个成员。

protected：继承的类可以访问父类中对应的成员。

类访问权限：类既不能是 private，也不能是 protected 的，只能使用 public 或者 是包访问权限。











