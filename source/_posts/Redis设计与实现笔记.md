---
title: Redis设计与实现笔记
date: 2020-10-18 23:14:52
tags: ["Redis"]
---

本文章是对《Redis设计与实现》书籍的一个整理笔记，记录了其中个人认为比较重要的部分。

<!-- More -->

## 第二章 简单动态字符串

+ SDS 定义：

![image-20201012191209564](image-20201012191209564.png)

+ SDS 与 C 字符串的区别：
  + 常数复杂度获取字符串的长度
  + 杜绝缓冲区溢出
  + 减少修改字符串时带来的内存分配的次数，包括空间预分配和惰性空间释放
  + 二进制安全
  + 兼容部分 C 字符串函数



## 第二章 链表

+ Redis 的链表实现的特性可以总结如下：

  + 双端
  + 无环
  + 带表头指针和表尾指针
  + 带链表长度计数器
  + 多态：链表节点使用void*指针来保存节点值, 并且可以通过 list 结构的dup, free, match三个属性为节点值设置类型特定函数,所以链表可以用于保存各种不同类型的值 

  ![image-20201012192406288](image-20201012192406288.png)



## 第三章 字典

+ Redis 普通状态下的字典：

  ![image-20201012194731429](image-20201012194731429.png)

+ 哈希算法：首先计算哈希值，然后计算出索引值

  ![image-20201012194922912](image-20201012194922912.png)

  > Redis 使用的 MurmurHash 算法计算建的哈希值，该算法的优点在于即使输入的键时有规律的，算法仍然能给出一个很好的随机分布性。

+ 解决键冲突：使用链地址法解决键冲突，使用头插法进行插入。

+ rehash：当负载因子过大的时候，就会开始进行相应的扩展或者收缩。使用`ht[1]`协助扩展。

+ 渐进式 rehash：扩展或收缩哈希表需要将`ht[0]`里面的所有键值对 rehash到`ht[1]` 里面, 但是, 这个 rehash动作并不是一次性、集中式地完成的,而是分多次、渐进式地完成。在渐进期间，字典会同时使用两个哈希表，但是插入的时候只会插入到`ht[1]`。



## 第五章 跳跃表

+ 跳跃表：有序的数据结构，通过在节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。支持 平均O(logn)，最坏O(N)复杂度的节点查找。

+ 跳跃表结构示意图：

  ![image-20201013191437427](image-20201013191437427.png)

  header和tail分别表示表头节点和表尾节点，level表示的层数，length时跳跃表的长度。BW表示的是回退指针，指向上一个跳跃表节点。箭头线上面的数字是跨度，表示跨过了几个节点。

+ 在Redis中，每个节点的层高是1到32之间的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的额成员对象必须唯一，另外，跳跃表中的节点按照分值大小排序，如果分值大小相同，则按照成员对象的大小排序。



## 第六章 整数集合

+ 整数集合实现：

  ![image-20201013192842489](image-20201013192842489.png)

  虽然contents是int8_t类型的数组，但实际上数组并不保存任何int8_t类型的值，该数组的真正类型取决于encoding属性的值。

+ 升级：每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时,整数集合需要先进行升级(upgrade)，然后才能将新元素添加到整数集合里面。首先根据新元素的类型，扩展整数集合底层数组的空间大小，并且为新元素分配相应的空间；将底层数组现有的所有元素都转换成与新元素相同的类型，并且将其放到正确的位置上，保持有序性不变；将新元素添加到底层数组里面（新元素要么在最后位置，要么在首位置）。

+ 升级的好处：提升灵活性，节约内存。

+ 降级：整数集合不支持降级操作，一旦对数据进行了升级，编码就会一直保持升级之后的状态。



## 第七章 压缩列表

+ 压缩列表的构成：

  ![image-20201013194653014](image-20201013194653014.png)

  zlbytes记录整个压缩列表占用的内存字节数，zltail记录列表表位距离压缩列表的起始地址有多少字节，zllen记录节点个数，zlend特殊值0xFF，标记为压缩列表的末端。

+ 压缩列表节点的构成：

  ![image-20201013195122854](image-20201013195122854.png)

  根据previous_entry_length可以计算出上一个节点的地址，根据encoding可以知道存放的数据类型和长度，content则是一个字节数组或者整数。

+ 连锁更新：当压缩列表的原来的节点的数值在250-254之间的时候，此时如果新增或者（删除）一个节点，会导致原来的首节点previous_entry_length大小从1字节转换为五个字节，从而引发连锁更新：

  ![image-20201013200603337](image-20201013200603337.png)

  尽管连锁更新的复杂度较高，但是真正造成性能问题的几率还是很低的。



## 第八章 对象

+ 对象的类型和编码：Redis中的对象的结构如下：

  ![image-20201013201146386](image-20201013201146386.png)

  其中，type表示对象的类型：

  ![image-20201013201321101](image-20201013201321101.png)

  对象的ptr指向对象的底层实现数据结构，而这些数据结构有对象的encoding属性决定：

  ![image-20201013201519317](image-20201013201519317.png)

  每种类型的对象至少使用了两种不同的编码：

  ![image-20201013201632078](image-20201013201632078.png)

  通过encoding来设定对象的编码，极大提高了Redis的灵活性和效率。

+ 字符串对象：编码可以是int，raw或者embstr。

+ 列表对象：编码可以是ziplist或者linkedlist。

+ 哈希对象：编码可以是ziplist或者hashtable。

+ 集合对象：编码可以是intset或者hashtable。

+ 有序集合对象：编码可以是ziplist或者skiplist。有序集合同时使用跳跃表可字典来实现的原因是能够让有序集合的查找和范围型的操作都尽可能快的执行，减少时间复杂度。

+ 类型检查和命令多态：类型检查的实现是通过键中的类型来进行的，命令的多态则是根据值对象的编码方式进行的。

  ![image-20201013203249016](image-20201013203249016.png)

+ 内存回收：采用引用计数的方式实现垃圾回收。

+ 对象共享：对象的引用计数属性还有对象共享的作用。目前来说, Redis会在初始化服务器时, 创建一万个字符串对象, 这些对象包含了从0 到9999的所有整数值, 当服务器需要用到值为0到9999的字符串对象时, 服务器就会使用这些共享对象, 而不是新创建对象。

+ 对象的空转时间：redisObject结构还包含了一个属性lru，用于记录对象最后一次被命令程序访问的时间。



## 第九章 数据库



